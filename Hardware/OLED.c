#include "oled.h"
#include <string.h>
#include <stdio.h>

// 你现有的 I2C 模块
extern void I2C1_Init(void);
extern int  I2C1_CheckAddr(uint8_t dev7);

// 如果你有 delay，用于上电等待（推荐）
extern void delay_ms(uint32_t ms);

// SSD1306 控制字节
#define OLED_CTRL_CMD   0x00
#define OLED_CTRL_DATA  0x40

static uint8_t g_oled_addr7 = OLED_ADDR_7BIT_DEFAULT;
static uint8_t g_oled_buf[OLED_W * (OLED_H / 8)]; // 1024 bytes

/* ====================== I2C 低层：更稳的发送（TXE/BTF轮询） ====================== */

static int I2C_WaitFlagSet(volatile uint32_t *reg, uint32_t mask, uint32_t timeout)
{
    while (((*reg) & mask) == 0)
    {
        if (timeout-- == 0) return 0;
    }
    return 1;
}

static int I2C_WaitNotBusy(uint32_t timeout)
{
    while (I2C1->SR2 & I2C_SR2_BUSY)
    {
        if (timeout-- == 0) return 0;
    }
    return 1;
}

static int I2C_StartAndAddr(uint8_t dev7, uint32_t timeout)
{
    if (!I2C_WaitNotBusy(timeout)) return 0;

    I2C_GenerateSTART(I2C1, ENABLE);
    if (!I2C_WaitFlagSet(&I2C1->SR1, I2C_SR1_SB, timeout)) return 0;

    I2C_Send7bitAddress(I2C1, (uint8_t)(dev7 << 1), I2C_Direction_Transmitter);

    // 等待 ADDR 或 AF
    while (((I2C1->SR1 & (I2C_SR1_ADDR | I2C_SR1_AF)) == 0) && timeout--) { }
    if (timeout == 0) return 0;

    if (I2C1->SR1 & I2C_SR1_AF)
    {
        I2C1->SR1 &= ~I2C_SR1_AF;
        return 0;
    }

    // 清 ADDR：读 SR1 再读 SR2
    (void)I2C1->SR1;
    (void)I2C1->SR2;
    return 1;
}

static int I2C_Write1(uint8_t byte, uint32_t timeout)
{
    // 等 TXE
    if (!I2C_WaitFlagSet(&I2C1->SR1, I2C_SR1_TXE, timeout)) return 0;
    I2C_SendData(I2C1, byte);
    return 1;
}

static int I2C_WaitBTF(uint32_t timeout)
{
    return I2C_WaitFlagSet(&I2C1->SR1, I2C_SR1_BTF, timeout);
}

/**
 * @brief  I2C 写：一次事务发送 [control] + data[len]
 */
static int I2C_WriteBlock(uint8_t dev7, uint8_t control, const uint8_t *data, uint16_t len)
{
    uint32_t tmo = 300000;

    if (!I2C_StartAndAddr(dev7, tmo))
    {
        I2C_GenerateSTOP(I2C1, ENABLE);
        return 0;
    }

    if (!I2C_Write1(control, tmo))
    {
        I2C_GenerateSTOP(I2C1, ENABLE);
        return 0;
    }

    for (uint16_t i = 0; i < len; i++)
    {
        if (!I2C_Write1(data[i], tmo))
        {
            I2C_GenerateSTOP(I2C1, ENABLE);
            return 0;
        }
    }

    // 等待最后一个字节真正移出（BTF）
    if (!I2C_WaitBTF(tmo))
    {
        I2C_GenerateSTOP(I2C1, ENABLE);
        return 0;
    }

    I2C_GenerateSTOP(I2C1, ENABLE);
    return 1;
}

/* ====================== SSD1306：写命令/写数据 ====================== */

static int OLED_WriteCmd(uint8_t cmd)
{
    return I2C_WriteBlock(g_oled_addr7, OLED_CTRL_CMD, &cmd, 1);
}

static int OLED_WriteData(const uint8_t *data, uint16_t len)
{
    return I2C_WriteBlock(g_oled_addr7, OLED_CTRL_DATA, data, len);
}

static void OLED_SetPos(uint8_t x, uint8_t page)
{
    OLED_WriteCmd(0xB0 | (page & 0x07));
    OLED_WriteCmd(0x00 | (x & 0x0F));
    OLED_WriteCmd(0x10 | ((x >> 4) & 0x0F));
}

/* ====================== 6x8 ASCII 字库（0x20~0x7F） ====================== */
static const uint8_t Font6x8[96][6] = {
    {0x00,0x00,0x00,0x00,0x00,0x00},{0x00,0x00,0x5f,0x00,0x00,0x00},{0x00,0x07,0x00,0x07,0x00,0x00},{0x14,0x7f,0x14,0x7f,0x14,0x00},
    {0x24,0x2a,0x7f,0x2a,0x12,0x00},{0x23,0x13,0x08,0x64,0x62,0x00},{0x36,0x49,0x55,0x22,0x50,0x00},{0x00,0x05,0x03,0x00,0x00,0x00},
    {0x00,0x1c,0x22,0x41,0x00,0x00},{0x00,0x41,0x22,0x1c,0x00,0x00},{0x14,0x08,0x3e,0x08,0x14,0x00},{0x08,0x08,0x3e,0x08,0x08,0x00},
    {0x00,0x50,0x30,0x00,0x00,0x00},{0x08,0x08,0x08,0x08,0x08,0x00},{0x00,0x60,0x60,0x00,0x00,0x00},{0x20,0x10,0x08,0x04,0x02,0x00},
    {0x3e,0x51,0x49,0x45,0x3e,0x00},{0x00,0x42,0x7f,0x40,0x00,0x00},{0x42,0x61,0x51,0x49,0x46,0x00},{0x21,0x41,0x45,0x4b,0x31,0x00},
    {0x18,0x14,0x12,0x7f,0x10,0x00},{0x27,0x45,0x45,0x45,0x39,0x00},{0x3c,0x4a,0x49,0x49,0x30,0x00},{0x01,0x71,0x09,0x05,0x03,0x00},
    {0x36,0x49,0x49,0x49,0x36,0x00},{0x06,0x49,0x49,0x29,0x1e,0x00},{0x00,0x36,0x36,0x00,0x00,0x00},{0x00,0x56,0x36,0x00,0x00,0x00},
    {0x08,0x14,0x22,0x41,0x00,0x00},{0x14,0x14,0x14,0x14,0x14,0x00},{0x00,0x41,0x22,0x14,0x08,0x00},{0x02,0x01,0x51,0x09,0x06,0x00},
    {0x32,0x49,0x79,0x41,0x3e,0x00},{0x7e,0x11,0x11,0x11,0x7e,0x00},{0x7f,0x49,0x49,0x49,0x36,0x00},{0x3e,0x41,0x41,0x41,0x22,0x00},
    {0x7f,0x41,0x41,0x22,0x1c,0x00},{0x7f,0x49,0x49,0x49,0x41,0x00},{0x7f,0x09,0x09,0x09,0x01,0x00},{0x3e,0x41,0x49,0x49,0x7a,0x00},
    {0x7f,0x08,0x08,0x08,0x7f,0x00},{0x00,0x41,0x7f,0x41,0x00,0x00},{0x20,0x40,0x41,0x3f,0x01,0x00},{0x7f,0x08,0x14,0x22,0x41,0x00},
    {0x7f,0x40,0x40,0x40,0x40,0x00},{0x7f,0x02,0x0c,0x02,0x7f,0x00},{0x7f,0x04,0x08,0x10,0x7f,0x00},{0x3e,0x41,0x41,0x41,0x3e,0x00},
    {0x7f,0x09,0x09,0x09,0x06,0x00},{0x3e,0x41,0x51,0x21,0x5e,0x00},{0x7f,0x09,0x19,0x29,0x46,0x00},{0x46,0x49,0x49,0x49,0x31,0x00},
    {0x01,0x01,0x7f,0x01,0x01,0x00},{0x3f,0x40,0x40,0x40,0x3f,0x00},{0x1f,0x20,0x40,0x20,0x1f,0x00},{0x3f,0x40,0x38,0x40,0x3f,0x00},
    {0x63,0x14,0x08,0x14,0x63,0x00},{0x07,0x08,0x70,0x08,0x07,0x00},{0x61,0x51,0x49,0x45,0x43,0x00},{0x00,0x7f,0x41,0x41,0x00,0x00},
    {0x02,0x04,0x08,0x10,0x20,0x00},{0x00,0x41,0x41,0x7f,0x00,0x00},{0x04,0x02,0x01,0x02,0x04,0x00},{0x40,0x40,0x40,0x40,0x40,0x00},
    {0x00,0x01,0x02,0x04,0x00,0x00},{0x20,0x54,0x54,0x54,0x78,0x00},{0x7f,0x48,0x44,0x44,0x38,0x00},{0x38,0x44,0x44,0x44,0x20,0x00},
    {0x38,0x44,0x44,0x48,0x7f,0x00},{0x38,0x54,0x54,0x54,0x18,0x00},{0x08,0x7e,0x09,0x01,0x02,0x00},{0x0c,0x52,0x52,0x52,0x3e,0x00},
    {0x7f,0x08,0x04,0x04,0x78,0x00},{0x00,0x44,0x7d,0x40,0x00,0x00},{0x20,0x40,0x44,0x3d,0x00,0x00},{0x7f,0x10,0x28,0x44,0x00,0x00},
    {0x00,0x41,0x7f,0x40,0x00,0x00},{0x7c,0x04,0x18,0x04,0x78,0x00},{0x7c,0x08,0x04,0x04,0x78,0x00},{0x38,0x44,0x44,0x44,0x38,0x00},
    {0x7c,0x14,0x14,0x14,0x38,0x00},{0x38,0x44,0x44,0x14,0x7c,0x00},{0x7c,0x08,0x04,0x04,0x08,0x00},{0x48,0x54,0x54,0x54,0x20,0x00},
    {0x04,0x3f,0x44,0x40,0x20,0x00},{0x3c,0x40,0x40,0x20,0x7c,0x00},{0x1c,0x20,0x40,0x20,0x1c,0x00},{0x3c,0x40,0x30,0x40,0x3c,0x00},
    {0x44,0x28,0x10,0x28,0x44,0x00},{0x0c,0x50,0x50,0x50,0x3c,0x00},{0x44,0x64,0x54,0x4c,0x44,0x00},{0x00,0x08,0x36,0x41,0x00,0x00},
    {0x00,0x00,0x7f,0x00,0x00,0x00},{0x00,0x41,0x36,0x08,0x00,0x00},{0x08,0x04,0x08,0x10,0x08,0x00},{0x00,0x00,0x00,0x00,0x00,0x00}
};

/* ====================== OLED API ====================== */

void OLED_Init(void)
{
    I2C1_Init();

    // 如果你有 delay，建议上电后等一下（无 delay 也不影响编译）
    // 不想要就注释掉
    delay_ms(100);

    // 自动探测地址
    if (I2C1_CheckAddr(0x3C)) g_oled_addr7 = 0x3C;
    else if (I2C1_CheckAddr(0x3D)) g_oled_addr7 = 0x3D;
    else
    {
        printf("OLED not found (0x3C/0x3D no ACK)\r\n");
        return;
    }
    printf("OLED addr=0x%02X\r\n", g_oled_addr7);

    // Init sequence (Page addressing)
    OLED_WriteCmd(0xAE);              // display off
    OLED_WriteCmd(0xD5); OLED_WriteCmd(0x80); // clock
    OLED_WriteCmd(0xA8); OLED_WriteCmd(0x3F); // multiplex 1/64
    OLED_WriteCmd(0xD3); OLED_WriteCmd(0x00); // display offset
    OLED_WriteCmd(0x40);              // start line
    OLED_WriteCmd(0x8D); OLED_WriteCmd(0x14); // charge pump
    OLED_WriteCmd(0x20); OLED_WriteCmd(0x02); // ★ 修正：页寻址模式
    OLED_WriteCmd(0xA1);              // seg remap
    OLED_WriteCmd(0xC8);              // com scan dec
    OLED_WriteCmd(0xDA); OLED_WriteCmd(0x12); // com pins
    OLED_WriteCmd(0x81); OLED_WriteCmd(0x7F); // contrast
    OLED_WriteCmd(0xD9); OLED_WriteCmd(0xF1); // precharge
    OLED_WriteCmd(0xDB); OLED_WriteCmd(0x40); // vcomh
    OLED_WriteCmd(0xA4);              // resume RAM display
    OLED_WriteCmd(0xA6);              // normal display
    OLED_WriteCmd(0xAF);              // display on

    OLED_Clear();
    OLED_Update();
}

void OLED_Clear(void)
{
    memset(g_oled_buf, 0, sizeof(g_oled_buf));
}

void OLED_Update(void)
{
    for (uint8_t page = 0; page < 8; page++)
    {
        OLED_SetPos(0, page);
        OLED_WriteData(&g_oled_buf[page * 128], 128);
    }
}

void OLED_DrawPoint(uint8_t x, uint8_t y, uint8_t color)
{
    if (x >= OLED_W || y >= OLED_H) return;
    uint16_t idx = (y / 8) * OLED_W + x;
    uint8_t bit = 1 << (y % 8);
    if (color) g_oled_buf[idx] |= bit;
    else       g_oled_buf[idx] &= (uint8_t)~bit;
}

void OLED_ShowChar(uint8_t x, uint8_t page, char c)
{
    if (x > 122 || page > 7) return;

    if ((uint8_t)c < 0x20 || (uint8_t)c > 0x7F) c = ' ';
    const uint8_t *p = Font6x8[(uint8_t)c - 0x20];

    uint16_t base = page * 128 + x;
    for (uint8_t i = 0; i < 6; i++)
    {
        if (x + i < 128) g_oled_buf[base + i] = p[i];
    }
}

void OLED_ShowString(uint8_t x, uint8_t page, const char *s)
{
    while (*s)
    {
        OLED_ShowChar(x, page, *s++);
        x += 6;
        if (x > 122)
        {
            x = 0;
            page++;
            if (page > 7) break;
        }
    }
}

void OLED_ShowNum(uint8_t x, uint8_t page, uint32_t num)
{
    char tmp[12];
    sprintf(tmp, "%lu", (unsigned long)num);
    OLED_ShowString(x, page, tmp);
}

void OLED_ShowSignedNum(uint8_t x, uint8_t page, int32_t num)
{
    char tmp[14];
    sprintf(tmp, "%ld", (long)num);
    OLED_ShowString(x, page, tmp);
}

uint8_t OLED_MapAdcToY(uint16_t adc, uint8_t y_top, uint8_t height)
{
    if (height == 0) return y_top;
    if (height > OLED_H) height = OLED_H;

    uint32_t y = ((uint32_t)adc * (height - 1)) / 4095;
    return (uint8_t)(y_top + (height - 1 - y));
}

void OLED_DrawWave_Adc128(const volatile uint16_t *p128,
                          uint8_t y_top, uint8_t height,
                          uint8_t clear_before)
{
    if (height == 0) return;
    if (y_top >= OLED_H) return;
    if ((uint16_t)y_top + height > OLED_H) height = OLED_H - y_top;

    if (clear_before)
    {
        for (uint8_t x = 0; x < 128; x++)
        {
            for (uint8_t y = y_top; y < (uint8_t)(y_top + height); y++)
                OLED_DrawPoint(x, y, 0);
        }
    }

    uint8_t y_prev = OLED_MapAdcToY(p128[0], y_top, height);
    OLED_DrawPoint(0, y_prev, 1);

    for (uint8_t x = 1; x < 128; x++)
    {
        uint8_t y_now = OLED_MapAdcToY(p128[x], y_top, height);
        OLED_DrawPoint(x, y_now, 1);

        if (y_now > y_prev)
        {
            for (uint8_t y = y_prev; y <= y_now; y++) OLED_DrawPoint(x, y, 1);
        }
        else
        {
            for (uint8_t y = y_now; y <= y_prev; y++) OLED_DrawPoint(x, y, 1);
        }

        y_prev = y_now;
    }
}
